# rev-requirements

## 목적

기존 코드베이스로부터 요구사항 정의서를 역생성합니다. 구현된 기능을 분석하여 EARS(Easy Approach to Requirements Syntax) 표기법을 사용하여 기능 요구사항, 비기능 요구사항, 사용자 스토리를 추출·문서화합니다.

## 전제 조건

- 분석 대상 코드베이스가 존재해야 함
- `docs/reverse/` 디렉토리가 존재해야 함 (없는 경우 생성)
- 가능하면 사전에 `rev-tasks.md` 및 `rev-design.md`를 실행해 둘 것

## 실행 내용

1. **기능의 특정과 분석**
   - UI 컴포넌트로부터 화면 기능을 추출
   - API 엔드포인트로부터 비즈니스 기능을 특정
   - 데이터베이스 스키마로부터 데이터 요구사항을 추정
   - 테스트 코드로부터 기대 동작을 확인

2. **사용자 스토리의 역산**
   - 구현된 기능으로부터 사용자의 의도를 추정
   - WHO(사용자 종별)의 특정
   - WHAT(실현하고 싶은 것)의 추출
   - WHY(얻을 수 있는 가치)의 추정

3. **EARS 표기법에 의한 요구사항 분류**
   - **일반 요구사항(SHALL)**: 표준적인 기능 구현으로부터 추출
   - **조건부 요구사항(WHEN/IF-THEN)**: 조건 분기 로직으로부터 추출
   - **상태 요구사항(WHERE)**: 상태 관리 구현으로부터 추출
   - **옵션 요구사항(MAY)**: 설정 가능 기능으로부터 추출
   - **제약 요구사항(MUST)**: 유효성 검사·제한 로직으로부터 추출

4. **비기능 요구사항의 추정**
   - 성능 요구사항: 구현된 캐시, 최적화로부터 추정
   - 보안 요구사항: 인증·인가 구현으로부터 추출
   - 사용성 요구사항: UI/UX 구현으로부터 추출
   - 운용 요구사항: 로그, 모니터링 구현으로부터 추출

5. **Edge 케이스의 특정**
   - 오류 처리 구현으로부터 예외 케이스 요구사항을 추출
   - 유효성 검사 구현으로부터 경계값 요구사항을 추출
   - 테스트 케이스로부터 예상되는 오류 케이스를 추출

6. **수락 기준의 생성**
   - 구현된 테스트로부터 수락 기준을 역산
   - 미구현의 테스트 케이스를 권장사항으로 제시

7. **파일의 생성**
   - `docs/reverse/{프로젝트명}-requirements.md`로 저장

## 출력 형식 예시

```markdown
# {프로젝트명} 요구사항 정의서 (역생성)

## 분석 개요

**분석 일시**: {실행일시}
**대상 코드베이스**: {경로}
**추출 요구사항 수**: {기능 요구사항 수}개의 기능 요구사항, {비기능 요구사항 수}개의 비기능 요구사항
**신뢰도**: {분석의 신뢰도} % (구현 커버리지에 기반)

## 시스템 개요

### 추정된 시스템 목적
{구현된 기능으로부터 추측되는 시스템의 목적}

### 대상 사용자
{UI 컴포넌트나 기능으로부터 추정되는 사용자 종별}

## 사용자 스토리

### 스토리1: 사용자 인증
- **이다** 미등록·기존 사용자 **로서**
- **나는** 시스템에 안전하게 로그인 **을 하고 싶다**
- **그렇게 함으로써** 개인적인 정보나 서비스에 접근할 수 있다

**구현 근거**: 
- `LoginForm.tsx` - 로그인 폼 구현
- `POST /auth/login` - 인증 API 구현
- `useAuth` 훅 - 인증 상태 관리

### 스토리2: {기타 스토리}

{구현된 기능으로부터 추정되는 추가의 사용자 스토리}

## 기능 요구사항 (EARS 표기법)

### 일반 요구사항

#### REQ-001: 사용자 인증
시스템은 유효한 이메일 주소와 비밀번호로의 사용자 로그인을 제공해야 한다.

**구현 근거**: 
- `auth.service.ts:login()` 메서드
- `POST /auth/login` 엔드포인트
- JWT 토큰 발행 구현

#### REQ-002: 세션 관리
시스템은 로그인 후의 사용자 세션을 관리해야 한다.

**구현 근거**:
- JWT 토큰에 의한 세션 관리
- `useAuth` 훅에서의 상태 관리
- 로컬 스토리지에서의 토큰 영속화

### 조건부 요구사항

#### REQ-101: 인증 실패 시의 처리
유효하지 않은 인증 정보가 제공된 경우, 시스템은 적절한 오류 메시지를 표시해야 한다.

**구현 근거**:
- `auth.controller.ts`의 오류 처리
- `LoginForm.tsx`의 오류 표시 구현

#### REQ-102: 토큰 만료 시의 처리
JWT 토큰이 만료된 경우, 시스템은 사용자를 재로그인 페이지로 리다이렉트해야 한다.

**구현 근거**:
- `axios.interceptors`에서의 401 오류 처리
- 자동 로그아웃 기능의 구현

### 상태 요구사항

#### REQ-201: 로그인 상태에서의 표시
사용자가 로그인 상태에 있는 경우, 시스템은 인증된 사용자용 UI를 표시해야 한다.

**구현 근거**:
- `useAuth` 훅에서의 인증 상태 확인
- 인증 상태에 의한 조건 분기 렌더링

### 옵션 요구사항

#### REQ-301: 로그인 상태의 기억
시스템은 사용자의 로그인 상태를 기억해도 된다.

**구현 근거**:
- 로컬 스토리지에서의 토큰 저장
- 자동 로그인 기능의 구현

### 제약 요구사항

#### REQ-401: 비밀번호 요구사항
시스템은 비밀번호에 최소 8자의 제약을 두어야 한다.

**구현 근거**:
- 프론트엔드 유효성 검사 구현
- `yup` 스키마에서의 제약 정의

#### REQ-402: 레이트 제한
시스템은 로그인 시도에 대해 레이트 제한을 두어야 한다.

**구현 근거**:
- `express-rate-limit` 미들웨어의 구현

## 비기능 요구사항

### 성능

#### NFR-001: 로그인 응답 시간
시스템은 일반적인 로그인 처리를 2초 이내에 완료해야 한다.

**구현 근거**:
- 데이터베이스 인덱스 설정
- 효율적인 쿼리 구현

#### NFR-002: 동시 사용자 수
시스템은 동시에 100 사용자의 접근을 처리할 수 있어야 한다.

**추정 근거**:
- 연결 풀 설정
- 서버 구성

### 보안

#### NFR-101: 인증 토큰 암호화
시스템은 JWT 토큰을 적절히 암호화해야 한다.

**구현 근거**:
- `jsonwebtoken` 라이브러리의 사용
- 비밀키에 의한 서명 구현

#### NFR-102: HTTPS 통신
시스템은 본番 환경에서 HTTPS 통신을 강제해야 한다.

**구현 근거**:
- SSL 설정 파일
- HTTPS 리다이렉트 구현

### 사용성

#### NFR-201: 반응형 디자인
시스템은 모바일 디바이스에서도 이용 가능해야 한다.

**구현 근거**:
- CSS 미디어 쿼리의 구현
- 반응형 UI 컴포넌트

#### NFR-202: 접근성
시스템은 기본적인 접근성 요구사항을 만족해야 한다.

**구현 근거**:
- ARIA 속성의 사용
- 시맨틱 HTML 구조

### 운용성

#### NFR-301: 로그 출력
시스템은 중요한 조작을 로그에 기록해야 한다.

**구현 근거**:
- `winston` 로그 라이브러리의 사용
- 구조화 로그의 구현

#### NFR-302: 오류 추적
시스템은 발생한 오류를 추적 가능해야 한다.

**구현 근거**:
- 오류 처리 구현
- 로그 출력에 의한 추적 기능

## Edge 케이스

### 오류 처리

#### EDGE-001: 네트워크 장애
네트워크 연결이 불안정한 경우의 재시도 처리

**구현 근거**:
- `axios`의 재시도 설정
- 오류 토스트 표시

#### EDGE-002: 서버 다운
백엔드 서버가 이용할 수 없는 경우의 처리

**구현 근거**:
- 폴백 기능
- 오류 페이지 표시

### 경계값

#### EDGE-101: 최대 문자수 제한
입력 필드의 최대 문자수 제한

**구현 근거**:
- 폼 유효성 검사 구현
- 데이터베이스 제약

#### EDGE-102: 빈 문자열·null 값 처리
빈 문자열이나 null 값에 대한 적절한 처리

**구현 근거**:
- 유효성 검사 구현
- 기본값 설정

## 수락 기준

### 구현된 기능 테스트

- [x] 사용자 로그인 기능
  - [x] 유효한 인증 정보로의 로그인 성공
  - [x] 유효하지 않은 인증 정보로의 로그인 실패
  - [x] 오류 메시지의 적절한 표시
- [x] 세션 관리 기능
  - [x] 로그인 상태의 유지
  - [x] 로그아웃 기능
  - [x] 토큰 만료 처리

### 권장 추가 테스트

- [ ] **성능 테스트**
  - [ ] 로그인 응답 시간 측정
  - [ ] 동시 접근 부하 테스트
- [ ] **보안 테스트**
  - [ ] SQL 인젝션 대책 테스트
  - [ ] XSS 대책 테스트
  - [ ] CSRF 대책 테스트
- [ ] **접근성 테스트**
  - [ ] 스크린 리더 대응 테스트
  - [ ] 키보드 조작 테스트

## 추정되지 않은 요구사항

### 불명확한 부분

다음의 요구사항은 구현으로부터 추정이 어려우므로, 스테이크홀더와의 확인이 필요:

1. **비즈니스 요구사항**
   - 시스템의 사용 목적의 상세
   - 대상 사용자의 상세한 속성
   - 수익 모델이나 사업 목표

2. **운용 요구사항**
   - 백업·복구 요구사항
   - SLA(서비스 레벨 합의)
   - 모니터링·알림 요구사항

3. **법적·컴플라이언스 요구사항**
   - 데이터 보호 규칙에의 준거
   - 업계 고유의 규제 요구사항

### 권장되는 다음 단계

1. **스테이크홀더 인터뷰** - 추정된 요구사항의 확인
2. **사용성 테스트** - 실제의 사용성 요구사항의 확인
3. **성능 테스트** - 비기능 요구사항의 검증
4. **보안 감사** - 보안 요구사항의 상세 검증

## 분석의 제약사항

### 신뢰도에 영향을 주는 요인

- **주석 부족**: 개발자의 의도를 추정으로 보완
- **테스트 커버리지**: {%}% - 미테스트 부분의 요구사항은 추정
- **문서 부족**: 외부 명세서가 존재하지 않음
- **레거시 코드**: 오래된 구현 패턴에 의한 추정의 어려움

### 추정의 근거

- **강한 근거**: 구현 + 테스트 + 명확한 동작
- **중간 정도의 근거**: 구현 + 부분적 테스트
- **약한 근거**: 구현만, 추정으로 보완

```

## 요구사항 추출 알고리즘

### 1. 기능 요구사항의 추출 프로세스

```
1. API 엔드포인트 → 비즈니스 기능 요구사항
2. UI 컴포넌트 → 사용자 인터페이스 요구사항
3. 데이터베이스 스키마 → 데이터 요구사항
4. 유효성 검사 구현 → 제약 요구사항
5. 조건 분기 → 조건부 요구사항
```

### 2. 비기능 요구사항의 추정 프로세스

```
1. 설정 파일 + 라이브러리 → 성능·보안 요구사항
2. UI 구현 패턴 → 사용성 요구사항
3. 로그·모니터링 구현 → 운용 요구사항
4. 테스트 구현 → 품질 요구사항
```

### 3. 사용자 스토리의 역산 프로세스

```
1. 화면 전환 플로우 → 사용자 저니
2. 폼·입력 항목 → 사용자 액션
3. 데이터의 CRUD 조작 → 사용자 니즈
4. 권한·롤 구현 → 사용자 종별
```

## 실행 명령어 예시

```bash
# 전체 분석 (모든 요구사항 추출)
claude code rev-requirements

# 특정 요구사항 카테고리만 추출
claude code rev-requirements --target functional
claude code rev-requirements --target non-functional
claude code rev-requirements --target user-stories

# 신뢰도 필터
claude code rev-requirements --confidence high
claude code rev-requirements --confidence medium

# 특정 디렉토리를 분석
claude code rev-requirements --path ./src

# 출력 형식 지정
claude code rev-requirements --format markdown,json
```

## 실행 후 확인

- 추출된 요구사항 수(기능 요구사항·비기능 요구사항)를 표시
- 분석의 신뢰도와 근거의 강함을 보고
- 추정이 어려운 요구사항이나 확인이 필요한 항목을 제시
- 스테이크홀더 확인을 위한 질문 리스트를 생성
- 다음의 권장 액션(테스트 추가, 문서 정비 등)을 제안
