# TDD Refactor 단계 (코드 개선)

TDD의 Refactor 단계를 실행합니다.

## 사전 준비

개발 컨텍스트를 준비합니다:

**Task 도구 실행**: `/tdd-load-context`로 TDD 관련 파일 로드 및 컨텍스트 준비 실행

로드 완료 후, 준비된 컨텍스트 정보를 바탕으로 Refactor 단계(코드 개선) 작업을 시작합니다.

## 신뢰성 수준 지시

리팩토링 시에는 각 개선 내용에 대해 원본 자료와의 대조 상황을 다음 신호로 표시해주세요:

- 🟢 **초록불**: 원본 자료를 참고하여 거의 추측하지 않은 경우
- 🟡 **노란불**: 원본 자료에서 타당한 추론인 경우
- 🔴 **빨간불**: 원본 자료에 없는 추론인 경우

## 목표

Green 단계에서 구현된 코드를 다음 관점에서 개선하세요. **테스트는 반드시 계속 통과**되어야 합니다.

## 개선의 관점

### 1. 가독성 향상

- 변수명・함수명 개선
- 한국어 주석 보완
- 코드 구조를 이해하기 쉽게

### 2. 중복 코드 제거 (DRY 원칙)

- 유사한 처리의 공통화
- 상수 추출
- 헬퍼 함수 생성

### 3. 설계 개선

- 단일 책임 원칙 적용
- 의존 관계 정리
- 모듈화 검토

### 4. 파일 크기 최적화

- 파일 크기가 500줄 미만이 되도록 분할・최적화
- 대용량 파일의 기능별 분할
- 적절한 모듈 경계 설정

### 5. 코드 품질 보장

- lint 오류 해결
- 타입 체크 오류 해결
- 포맷 통일
- 정적 분석 도구 체크 통과

### 6. 보안 리뷰

- 취약점으로 이어질 수 있는 구현 검출 및 수정
- 입력값 검증 강화
- SQL 인젝션 대응 확인
- XSS(크로스 사이트 스크립팅) 대응 확인
- CSRF(사이트 간 요청 위조) 대응 확인
- 데이터 유출 위험 회피
- 인증・인가의 적절한 구현

### 7. 성능 리뷰

- 알고리즘의 계산 복잡도 분석
- 메모리 사용량 최적화
- 불필요한 처리 제거
- 캐시 전략 검토
- 데이터베이스 쿼리 최적화
- 루프 처리 효율화
- 비동기 처리의 적절한 구현

### 8. 에러 처리 강화

- 입력값 검증
- 적절한 오류 메시지
- 예외 처리 개선

## 리팩토링 시 한국어 주석 강화 요구사항

리팩토링 시 기존 한국어 주석을 개선하고, 새로운 주석을 추가하세요:

### 개선된 함수・메서드의 주석

```javascript
/**
 * 【기능 개요】: [리팩토링 후 기능의 상세 설명]
 * 【개선 내용】: [어떤 개선을 했는지 설명]
 * 【설계 방향】: [왜 이 설계로 했는지 이유]
 * 【성능】: [성능 면에서의 고려사항]
 * 【유지보수성】: [유지보수하기 쉽게 하기 위한 고려사항]
 * 🟢🟡🔴 신뢰성 수준: [이 개선이 원본 자료의 어느 정도에 기반하는지]
 * @param {type} paramName - [매개변수의 상세 설명과 제약사항]
 * @returns {type} - [반환값의 상세 설명과 보장사항]
 */
function improvedFunction(paramName) {
  // 【구현 상세】: [개선된 구현 내용과 이유]
}
```

### 헬퍼 함수・유틸리티의 주석

```javascript
/**
 * 【헬퍼 함수】: [이 함수의 역할과 생성 이유]
 * 【재사용성】: [어떤 상황에서 재사용할 수 있는지]
 * 【단일 책임】: [이 함수가 담당하는 책임의 범위]
 */
function helperFunction(input) {
  // 【처리 효율화】: [처리를 효율화하기 위한 고려사항] 🟢🟡🔴
  // 【가독성 향상】: [코드의 가독성을 높이기 위한 장치] 🟢🟡🔴
}
```

### 상수・설정값의 주석

```javascript
// 【설정 상수】: [이 상수의 역할과 설정 이유] 🟢🟡🔴
// 【조정 가능성】: [앞으로 조정이 필요할 가능성과 방법] 🟢🟡🔴
const IMPROVED_CONSTANT = 100; // 【최적화 완료】: 성능 테스트를 기반으로 최적화 🟢🟡🔴

// 【설정 객체】: [설정을 모아둔 이유와 관리 방침]
const CONFIG = {
  // 【각 설정 항목】: [각 설정값의 의미와 영향 범위]
  maxRetries: 3, // 【재시도 횟수】: 실제 운영 경험을 바탕으로 한 적절한 횟수
  timeout: 5000, // 【타임아웃】: 사용자 경험을 고려한 시간 설정
};
```

### 에러 처리 개선의 주석

```javascript
try {
  // 【안전한 처리 실행】: [예외가 발생할 가능성과 대책]
  const result = riskyOperation();
} catch (error) {
  // 【상세 에러 처리】: [에러 종류에 따른 적절한 처리]
  // 【사용자 경험】: [사용자에게 이해하기 쉬운 오류 대응]
  if (error.code === 'SPECIFIC_ERROR') {
    // 【특정 에러 대응】: [이 에러에 특화된 처리의 이유]
    return handleSpecificError(error);
  }
  // 【일반 에러 대응】: [예상치 못한 에러에 대한 안전한 대처]
  return handleGenericError(error);
}
```

## 리팩토링 절차

1. **현재 테스트가 모두 통과하는지 확인**
   - 【품질 보증】: 리팩토링 전 동작 확인
   - 【안전성 확보】: 변경으로 인한 기능 손상 방지
   - 【실행 방법】: Task 도구를 사용하여 테스트 실행 후 결과를 상세히 분석

2. **코드・테스트 제외 체크**
   - 【.gitignore 확인】: 확인이 필요한 코드 파일이 제외되지 않았는지 확인
   - 【테스트 제외 확인】: `describe.skip`, `it.skip`, `test.skip` 등으로 테스트가 비활성화되지 않았는지 확인
   - 【jest 설정 확인】: `jest.config.js`나 `package.json`의 `testPathIgnorePatterns` 등으로 테스트 파일이 제외되지 않았는지 확인
   - 【실행 대상 확인】: 실제로 실행되어야 할 테스트와 코드가 적절히 포함되어 있는지 확인

3. **개발 시 생성된 파일 정리**
   - 【불필요 파일 탐지】: 개발 중 생성된 임시 파일 탐지 및 삭제
   - 【대상 파일 패턴】: 다음 패턴에 해당하는 파일 확인
     - `debug-*.js`, `debug-*.ts`: 디버깅용 스크립트
     - `test-*.js`, `test-*.ts`, `temp-*.js`: 임시 테스트 파일
     - `*.tmp`, `*.temp`, `*.bak`, `*.orig`: 임시・백업 파일
     - `*~`, `.DS_Store`: 에디터・시스템 생성 파일
     - `test-output-*`, `*.test-output`: 테스트 출력 파일
   - 【안전 확인】: 삭제 전 각 파일 내용을 확인하고, 중요한 코드가 포함되지 않았는지 확인
   - 【선택적 삭제】: 불필요하다고 판단된 파일만 삭제하고, 필요한 파일은 보존
   - 【삭제 로그】: 삭제한 파일과 삭제 이유를 로그로 기록
   - 【실행 절차】: 
     1. `find . -name "debug-*" -o -name "test-*" -o -name "temp-*" -o -name "*.tmp" -o -name "*.temp" -o -name "*.bak" -o -name "*.orig" -o -name "*~" -o -name ".DS_Store" | grep -v node_modules`로 파일 탐지
     2. 각 파일의 내용을 Read 도구로 확인
     3. 불필요하다고 판단된 파일은 삭제하고, 삭제 이유 기록

4. **보안 리뷰 수행**
   - 【취약점 검사】: 코드 전체의 보안 허점 식별
   - 【입력 검증 확인】: 잘못된 입력값에 대한 방어 기능 확인
   - 【보안 가이드라인 적용】: 업계 표준 보안 모범 사례 적용

5. **성능 리뷰 수행**
   - 【계산 복잡도 분석】: 알고리즘의 시간 복잡도・공간 복잡도 평가
   - 【병목 현상 식별】: 처리 속도나 메모리 사용량의 문제 지점 식별
   - 【최적화 전략】: 구체적인 성능 개선 방안 수립

6. **작은 개선 사항을 하나씩 적용**
   - 【단계적 개선】: 영향 범위가 제한된 안전한 변경
   - 【추적 가능성】: 변경 내용의 추적성 보장

7. **각 개선 후 테스트 실행**
   - 【지속적 검증】: 개선할 때마다 동작 확인
   - 【조기 발견】: 문제의 조기 발견 및 수정
   - 【실행 방법】: Task 도구를 사용하여 테스트 실행 후 개선 사항의 영향 확인

8. **테스트가 실패하면 즉시 되돌리기**
   - 【신속한 복구】: 문제 발생 시 빠른 대응
   - 【안정성 유지】: 시스템의 안정된 상태 유지

## 주의사항

- **기능적인 변경은 하지 않음** (신규 기능 추가는 금지)
- **테스트는 항상 통과해야 함** (리팩토링 후에도 동일한 동작 보장)
- **점진적인 개선**을 원칙으로 함 (한 번에 너무 많은 변경 금지)
- **커밋은 작게** 자주 수행 (문제 발생 시 쉽게 되돌릴 수 있도록)

## 리팩토링 완료 후

1. **변경 사항 문서화**
   - 【변경 내역】: 어떤 부분을 어떻게 개선했는지 상세히 기록
   - 【개선 효과】: 개선 전후의 성능, 가독성 등의 비교
   - 【향후 과제】: 추가로 개선이 필요한 사항

2. **리뷰 요청**
   - 【코드 리뷰】: 팀원에게 리뷰 요청
   - 【피드백 반영】: 리뷰 의견을 바탕으로 추가 개선

3. **메인 브랜치 병합**
   - 【충돌 해결】: 병합 전 충돌 사항 해결
   - 【테스트 재실행】: 병합 후 전체 테스트 재실행

## 리팩토링 결과물

1. **개선된 코드**
2. **업데이트된 테스트**
3. **변경 사항 문서**
4. **성능 측정 결과** (해당되는 경우)
5. **보안 검토 결과** (해당되는 경우)
6. **품질 평가**: 현재 코드의 품질 수준 (보안・성능 평가 포함)
7. **주석 개선 내용**: 한국어 주석을 어떻게 강화했는지

## 리팩토링 예시

```javascript
// 리팩토링 전
function processData(data) {
  let result = [];
  for (let i = 0; i < data.length; i++) {
    if (data[i].value > 10) {
      result.push(data[i].value * 2);
    }
  }
  return result;
}

// 리팩토링 후
/**
 * 【기능 개요】: 입력 데이터에서 특정 조건을 만족하는 값만 추출하여 변환
 * 【개선 내용】: 가독성 향상과 함수형 프로그래밍 스타일 적용
 * 【설계 방향】: 단일 책임 원칙에 따라 데이터 필터링과 변환을 명확히 분리
 * 【성능】: O(n) 시간 복잡도 유지
 * 【유지보수성】: 각 단계별로 명확한 의도를 가진 메서드 체이닝 사용
 * 🟢 신뢰성 수준: 기존 로직을 유지하면서 개선
 * @param {Array<{value: number}>} data - 처리할 데이터 배열
 * @returns {number[]} - 조건을 만족하는 값들을 2배로 변환한 배열
 */
function processData(data) {
  // 【유효성 검사】: 입력 데이터 검증
  if (!Array.isArray(data)) {
    throw new Error('데이터는 배열이어야 합니다.');
  }

  // 【데이터 처리】: 필터링과 매핑을 체이닝으로 연결
  return data
    .filter(item => item?.value > 10) // 【조건 필터링】: 값이 10 초과인 항목만 선택
    .map(item => item.value * 2);     // 【데이터 변환】: 선택된 항목의 값을 2배로 변환
}
```
