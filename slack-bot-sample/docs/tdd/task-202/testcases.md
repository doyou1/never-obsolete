# TASK-202: 플로우 추적 엔진 테스트 케이스

## 1. FlowTracker 클래스 테스트

### 1.1 생성자 및 초기화 테스트

#### TC-202-001: FlowTracker 인스턴스 생성
- **입력**: 기본 설정
- **예상 결과**: FlowTracker 인스턴스 생성됨
- **검증**: instance instanceof FlowTracker

#### TC-202-002: 설정 옵션 적용
- **입력**: `{ maxDepth: 5, maxNodes: 100 }`
- **예상 결과**: 설정이 올바르게 적용됨
- **검증**: getConfig() 메서드로 설정값 확인

### 1.2 기본 플로우 추적 테스트

#### TC-202-003: 단순 플로우 추적
- **입력**: 단일 API 엔드포인트 → 단일 함수
- **예상 결과**: 2개 노드, 1개 엣지를 가진 그래프
- **검증**:
  - `graph.nodes.length === 2`
  - `graph.edges.length === 1`
  - 엔트리 포인트가 API 엔드포인트

#### TC-202-004: 다층 플로우 추적
- **입력**: API → Controller → Service → Repository → DB
- **예상 결과**: 5개 노드, 4개 엣지를 가진 선형 그래프
- **검증**:
  - 모든 계층이 올바른 순서로 연결됨
  - 각 노드의 타입이 정확함

#### TC-202-005: 다중 진입점 처리
- **입력**: 2개의 다른 API 엔드포인트
- **예상 결과**: 2개의 진입점을 가진 그래프
- **검증**:
  - `graph.entryPoints.length === 2`
  - 각 진입점에서 독립적인 플로우

## 2. EntryPointDetector 테스트

### 2.1 라우터 파일 분석

#### TC-202-006: GET 엔드포인트 탐지
- **입력**: `app.get('/users', userController.getUsers)`
- **예상 결과**: GET /users 엔드포인트 감지
- **검증**:
  - method: 'GET'
  - path: '/users'
  - handler: 'userController.getUsers'

#### TC-202-007: RESTful 엔드포인트 탐지
- **입력**: CRUD 엔드포인트가 정의된 라우터 파일
- **예상 결과**: 모든 HTTP 메서드 감지 (GET, POST, PUT, DELETE)
- **검증**:
  - 4개의 엔드포인트 탐지
  - 각 메서드가 정확히 매핑됨

#### TC-202-008: 동적 라우트 처리
- **입력**: `'/users/:id'` 형태의 동적 라우트
- **예상 결과**: 파라미터를 포함한 라우트 패턴 인식
- **검증**:
  - path에 :id 파라미터 포함
  - 파라미터 메타데이터 추출

### 2.2 에러 처리

#### TC-202-009: 잘못된 라우터 파일
- **입력**: 구문 오류가 있는 라우터 파일
- **예상 결과**: 에러를 던지지 않고 빈 배열 반환
- **검증**:
  - 예외 발생하지 않음
  - 빈 엔드포인트 목록 반환

#### TC-202-010: 존재하지 않는 파일
- **입력**: 존재하지 않는 라우터 파일 경로
- **예상 결과**: FileNotFoundError 발생
- **검증**: 적절한 에러 메시지와 타입

## 3. DependencyMapper 테스트

### 3.1 의존성 매핑

#### TC-202-011: 함수 호출 추적
- **입력**: `userService.findById(id)` 함수 호출
- **예상 결과**: userService.findById로의 의존성 엣지 생성
- **검증**:
  - 소스: 현재 함수
  - 타겟: userService.findById
  - 타입: 'call'

#### TC-202-012: Import 관계 매핑
- **입력**: `import { UserService } from './services/UserService'`
- **예상 결과**: UserService에 대한 의존성 생성
- **검증**:
  - 임포트 관계가 의존성으로 변환됨
  - 파일 경로가 정확히 해결됨

#### TC-202-013: 데이터베이스 쿼리 감지
- **입력**: `await db.query('SELECT * FROM users')`
- **예상 결과**: 데이터베이스 노드로의 엣지 생성
- **검증**:
  - 타겟 노드 타입: 'database'
  - 쿼리 정보가 메타데이터에 포함

### 3.2 복잡한 의존성

#### TC-202-014: 간접 의존성 추적
- **입력**: A → B → C 형태의 간접 호출
- **예상 결과**: 전체 호출 체인이 추적됨
- **검증**:
  - 3개 노드가 연결됨
  - 호출 순서가 보존됨

#### TC-202-015: 조건부 의존성 처리
- **입력**: if문 내부의 조건부 함수 호출
- **예상 결과**: 조건부 의존성으로 표시
- **검증**:
  - 엣지에 조건부 메타데이터 포함
  - 의존성이 여전히 추적됨

## 4. 순환 의존성 감지 테스트

### 4.1 순환 감지

#### TC-202-016: 단순 순환 의존성
- **입력**: A → B → A 형태의 순환
- **예상 결과**: 순환 의존성 감지
- **검증**:
  - `circularDependencies.length === 1`
  - 순환에 포함된 노드들 ['A', 'B']

#### TC-202-017: 복잡한 순환 의존성
- **입력**: A → B → C → D → B 형태
- **예상 결과**: B, C, D가 순환 그룹으로 감지
- **검증**:
  - 순환 그룹 ['B', 'C', 'D'] 식별
  - A는 순환에 포함되지 않음

#### TC-202-018: 다중 순환 의존성
- **입력**: 두 개의 독립적인 순환
- **예상 결과**: 2개의 별도 순환 그룹 감지
- **검증**:
  - `circularDependencies.length === 2`
  - 각 순환이 독립적으로 식별

### 4.2 순환 없는 경우

#### TC-202-019: DAG (Directed Acyclic Graph)
- **입력**: 순환이 없는 복잡한 의존성 그래프
- **예상 결과**: 순환 의존성 없음으로 보고
- **검증**:
  - `circularDependencies.length === 0`
  - 모든 노드가 올바르게 처리됨

## 5. FlowGraphGenerator 테스트

### 5.1 그래프 생성

#### TC-202-020: 빈 그래프 생성
- **입력**: 빈 AST 데이터
- **예상 결과**: 빈 노드와 엣지를 가진 그래프
- **검증**:
  - 노드 0개, 엣지 0개
  - 유효한 그래프 구조

#### TC-202-021: 단일 파일 그래프
- **입력**: 하나의 파일 데이터
- **예상 결과**: 파일과 그 내부 요소들을 나타내는 그래프
- **검증**:
  - 파일 노드 1개
  - 함수/클래스 노드들 추가

#### TC-202-022: 대용량 그래프 생성
- **입력**: 100개 파일, 1000개 함수
- **예상 결과**: 메모리 제한 내에서 그래프 생성 완료
- **검증**:
  - 메모리 사용량 < 500MB
  - 처리 시간 < 10초

### 5.2 메타데이터 포함

#### TC-202-023: 노드 메타데이터
- **입력**: 위치 정보가 있는 함수
- **예상 결과**: 노드에 위치 정보 포함
- **검증**:
  - position 필드 존재
  - 라인 번호 정확함

#### TC-202-024: 엣지 메타데이터
- **입력**: 파라미터가 있는 함수 호출
- **예상 결과**: 엣지에 파라미터 정보 포함
- **검증**:
  - 호출 파라미터 메타데이터
  - 반환 타입 정보

## 6. 성능 테스트

### 6.1 처리 속도

#### TC-202-025: 100개 파일 처리 성능
- **입력**: 100개의 TypeScript 파일
- **예상 결과**: 1초 이내 완료
- **검증**: 처리 시간 측정

#### TC-202-026: 메모리 사용량 테스트
- **입력**: 대용량 프로젝트 (1000개 파일)
- **예상 결과**: 메모리 사용량 500MB 이하
- **검증**: process.memoryUsage() 모니터링

### 6.2 제한 조건 테스트

#### TC-202-027: 최대 깊이 제한
- **입력**: 15단계 깊이의 호출 체인
- **예상 결과**: 10단계에서 추적 중단
- **검증**:
  - 그래프 최대 깊이 10
  - 더 깊은 호출은 무시됨

#### TC-202-028: 최대 노드 수 제한
- **입력**: 2000개 노드를 생성할 데이터
- **예상 결과**: 1000개 노드에서 중단
- **검증**:
  - `graph.nodes.length <= 1000`
  - 제한 초과 시 경고 메시지

## 7. 에러 처리 테스트

### 7.1 파일 시스템 오류

#### TC-202-029: 파일 접근 권한 오류
- **입력**: 읽기 권한이 없는 파일
- **예상 결과**: 해당 파일을 건너뛰고 계속 진행
- **검증**:
  - 예외 발생하지 않음
  - 다른 파일들은 정상 처리

#### TC-202-030: 깨진 심볼릭 링크
- **입력**: 존재하지 않는 파일을 가리키는 심볼릭 링크
- **예상 결과**: 링크를 무시하고 진행
- **검증**: 에러 없이 완료

### 7.2 데이터 무결성 오류

#### TC-202-031: 잘못된 AST 데이터
- **입력**: null 또는 undefined AST 노드
- **예상 결과**: 적절한 에러 메시지와 함께 처리 중단
- **검증**:
  - 명확한 에러 메시지
  - 스택 트레이스 포함

#### TC-202-032: 불완전한 메타데이터
- **입력**: 필수 필드가 누락된 메타데이터
- **예상 결과**: 기본값으로 대체하여 처리
- **검증**:
  - 처리 계속됨
  - 경고 로그 출력

## 8. 통합 테스트

### 8.1 실제 프로젝트 테스트

#### TC-202-033: clientv 디렉토리 분석
- **입력**: 실제 clientv 디렉토리
- **예상 결과**: 라우터에서 시작하는 완전한 플로우 그래프
- **검증**:
  - 모든 API 엔드포인트 탐지
  - 서버 코드까지의 연결 확인

#### TC-202-034: 전체 시스템 통합
- **입력**: AST 파서 출력 → 플로우 트래커
- **예상 결과**: 끝단간 플로우 추적 성공
- **검증**:
  - Client → API → Server → DB 완전한 트레이스
  - 모든 의존성 관계 정확히 매핑

### 8.2 엣지 케이스

#### TC-202-035: 빈 프로젝트
- **입력**: 파일이 없는 디렉토리
- **예상 결과**: 빈 그래프 생성
- **검증**: 에러 없이 빈 결과 반환

#### TC-202-036: TypeScript + JavaScript 혼합
- **입력**: .ts와 .js 파일이 혼재한 프로젝트
- **예상 결과**: 모든 파일 타입이 올바르게 처리됨
- **검증**:
  - TypeScript/JavaScript 파일 모두 분석
  - 상호 의존성 추적

## 9. 출력 검증 테스트

### 9.1 그래프 구조 검증

#### TC-202-037: 그래프 무결성
- **입력**: 복잡한 의존성을 가진 프로젝트
- **예상 결과**: 모든 엣지가 유효한 노드를 참조
- **검증**:
  - 모든 엣지의 source/target이 존재
  - 고아 노드 없음

#### TC-202-038: 통계 정확성
- **입력**: 알려진 구조의 프로젝트
- **예상 결과**: 정확한 통계 정보
- **검증**:
  - 노드/엣지 수가 정확함
  - 최대 깊이가 올바름

### 9.2 출력 포맷 검증

#### TC-202-039: JSON 직렬화
- **입력**: 생성된 플로우 그래프
- **예상 결과**: 유효한 JSON으로 직렬화 가능
- **검증**:
  - JSON.stringify() 성공
  - 순환 참조 없음

#### TC-202-040: 스키마 준수
- **입력**: 플로우 그래프 출력
- **예상 결과**: 정의된 인터페이스 스키마 준수
- **검증**:
  - FlowGraph 인터페이스 준수
  - 모든 필수 필드 존재